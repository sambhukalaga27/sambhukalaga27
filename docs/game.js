const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const statusEl = document.getElementById("status");
const metaEl = document.getElementById("meta");

function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

function resize() {
  const cssW = canvas.clientWidth;
  const cssH = canvas.clientHeight;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.floor(cssW * dpr);
  canvas.height = Math.floor(cssH * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener("resize", resize);
resize();

let blocks = [];
let bullets = [];
let particles = [];
let score = 0;
let running = true;

const jet = { x: 0, y: 0, w: 26, h: 30, speed: 6 };
const keys = new Set();
let lastShotAt = 0;

window.addEventListener("keydown", (e) => {
  if (["ArrowLeft","ArrowRight","a","d","A","D"," "].includes(e.key)) e.preventDefault();
  keys.add(e.key);
  if (e.key.toLowerCase() === "r") resetGame();
});
window.addEventListener("keyup", (e) => keys.delete(e.key));

function aabbHit(ax, ay, aw, ah, bx, by, bw, bh) {
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

function spawnExplosion(x, y, n = 14) {
  for (let i = 0; i < n; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 3.2,
      vy: (Math.random() - 0.5) * 3.2,
      life: 40 + Math.random() * 30,
    });
  }
}

function computeHP(count) {
  // small contributions die fast, big ones take more shots
  // 1..2 => 1hp, 3..6 => 2hp, 7..14 => 3hp, 15..30 => 4hp, 31+ => 5hp
  if (count <= 2) return 1;
  if (count <= 6) return 2;
  if (count <= 14) return 3;
  if (count <= 30) return 4;
  return 5;
}

function layoutBlocks(days, meta) {
  const WEEKS = 53; // GitHub-style grid width
  const paddingX = 20;
  const topY = 56;

  const availableW = canvas.clientWidth - paddingX * 2;
  const cell = clamp(Math.floor(availableW / WEEKS) - 2, 8, 16);
  const gap = 2;
  const gridW = WEEKS * (cell + gap) - gap;
  const originX = Math.floor((canvas.clientWidth - gridW) / 2);

  const built = [];
  for (const d of days) {
    if (!d || !d.date) continue;
    if (!Number.isFinite(d.weekIndex) || !Number.isFinite(d.weekday)) continue;
    if ((d.contributionCount ?? d.count ?? 0) <= 0) continue;

    const count = d.contributionCount ?? d.count ?? 0;
    const color = d.color || "#2ea043";

    const x = originX + d.weekIndex * (cell + gap);
    const y = topY + d.weekday * (cell + gap);

    built.push({
      x, y, w: cell, h: cell,
      count,
      hp: computeHP(count),
      color
    });
  }

  return { built, cell, gap, originX, topY, meta };
}

function resetGame() {
  score = 0;
  bullets = [];
  particles = [];
  // rebuild from original template blocks (kept in state)
  blocks = (window.__initialBlocks || []).map(b => ({ ...b }));
  running = true;
  statusEl.textContent = "Ready. Shoot.";
}

async function loadContribData() {
  // file is generated by the scheduled GitHub Action
  const res = await fetch("./data/contributions.json", { cache: "no-store" });
  if (!res.ok) throw new Error(`Failed to load contributions.json (${res.status})`);
  return res.json();
}

function drawJet() {
  // simple triangle jet
  const x = jet.x, y = jet.y;
  ctx.save();
  ctx.translate(x, y);

  ctx.fillStyle = "#e6edf3";
  ctx.beginPath();
  ctx.moveTo(0, -jet.h / 2);
  ctx.lineTo(-jet.w / 2, jet.h / 2);
  ctx.lineTo(jet.w / 2, jet.h / 2);
  ctx.closePath();
  ctx.fill();

  // tiny flame
  ctx.fillStyle = "#ff7b72";
  ctx.beginPath();
  ctx.moveTo(0, jet.h / 2 + 10);
  ctx.lineTo(-6, jet.h / 2 - 2);
  ctx.lineTo(6, jet.h / 2 - 2);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

function draw() {
  ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

  // title-ish line
  ctx.fillStyle = "rgba(255,255,255,0.12)";
  ctx.fillRect(0, 44, canvas.clientWidth, 1);

  // blocks
  for (const b of blocks) {
    ctx.fillStyle = b.color;
    ctx.fillRect(b.x, b.y, b.w, b.h);

    // outline
    ctx.strokeStyle = "rgba(0,0,0,0.35)";
    ctx.strokeRect(b.x + 0.5, b.y + 0.5, b.w - 1, b.h - 1);

    // hp hint (small dots)
    const dots = b.hp;
    for (let i = 0; i < dots; i++) {
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fillRect(b.x + 2 + i * 3, b.y + b.h - 4, 2, 2);
    }
  }

  // bullets
  ctx.fillStyle = "#79c0ff";
  for (const s of bullets) {
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    ctx.fill();
  }

  // particles
  ctx.fillStyle = "rgba(255,255,255,0.65)";
  for (const p of particles) {
    ctx.fillRect(p.x, p.y, 2, 2);
  }

  // jet
  drawJet();

  // HUD
  ctx.fillStyle = "rgba(230,237,243,0.9)";
  ctx.font = "14px ui-sans-serif, system-ui";
  ctx.fillText(`Score: ${score}`, 16, 28);
  ctx.fillText(`Blocks left: ${blocks.length}`, 120, 28);
}

function update() {
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;

  jet.y = h - 60;
  if (!jet.x) jet.x = w / 2;

  // movement
  const left = keys.has("ArrowLeft") || keys.has("a") || keys.has("A");
  const right = keys.has("ArrowRight") || keys.has("d") || keys.has("D");
  if (left) jet.x -= jet.speed;
  if (right) jet.x += jet.speed;
  jet.x = clamp(jet.x, 20, w - 20);

  // shooting
  const now = performance.now();
  const shoot = keys.has(" ");
  if (shoot && now - lastShotAt > 120 && running) {
    bullets.push({ x: jet.x, y: jet.y - 18, vy: -9.5, r: 3 });
    lastShotAt = now;
  }

  // bullets move
  for (const s of bullets) s.y += s.vy;
  bullets = bullets.filter(s => s.y > -20);

  // collisions
  if (running) {
    for (let i = bullets.length - 1; i >= 0; i--) {
      const s = bullets[i];
      let hitIndex = -1;

      for (let j = 0; j < blocks.length; j++) {
        const b = blocks[j];
        if (aabbHit(s.x - s.r, s.y - s.r, s.r * 2, s.r * 2, b.x, b.y, b.w, b.h)) {
          hitIndex = j;
          break;
        }
      }

      if (hitIndex !== -1) {
        const b = blocks[hitIndex];
        b.hp -= 1;
        bullets.splice(i, 1);

        if (b.hp <= 0) {
          score += Math.max(1, Math.min(10, Math.floor(b.count / 3)));
          spawnExplosion(b.x + b.w / 2, b.y + b.h / 2);
          blocks.splice(hitIndex, 1);
          if (blocks.length === 0) {
            running = false;
            statusEl.textContent = "All blocks cleared. Press R to replay.";
          }
        }
      }
    }
  }

  // particles
  for (const p of particles) {
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 0.98;
    p.vy *= 0.98;
    p.life -= 1;
  }
  particles = particles.filter(p => p.life > 0);
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

(async function main() {
  try {
    const data = await loadContribData();

    const days = data.days || [];
    const meta = {
      generatedAt: data.generatedAt,
      from: data.from,
      to: data.to,
      total: data.total,
      username: data.username,
      repo: data.repo
    };

    const laid = layoutBlocks(days, meta);
    blocks = laid.built;

    // keep a pristine copy for reset
    window.__initialBlocks = blocks.map(b => ({ ...b }));

    statusEl.textContent = `Loaded ${blocks.length} contribution blocks.`;
    metaEl.textContent =
      `Synced for ${meta.username || "user"} | range ${meta.from?.slice(0,10)} â†’ ${meta.to?.slice(0,10)} | generated ${meta.generatedAt?.slice(0,19).replace("T"," ")}`;

    loop();
  } catch (e) {
    statusEl.textContent = `Could not load contribution data. (${e.message})`;
    console.error(e);
  }
})();
